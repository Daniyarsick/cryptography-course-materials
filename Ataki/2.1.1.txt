# Аннануров Даниил 3 курс

# Вычисление закрытого ключа по открытому

with(numtheory):
with(RandomTools):

# Генерация секретных простых чисел (известны только владельцу ключа)
# q1, q2, phB не известны взломщику
# - известного открытого ключа (rB, e)

q1 := nextprime(Generate(integer(range=3..10^15)));
q2 := nextprime(Generate(integer(range=3..10^15)));

# Вычисление функции Эйлера для произведения q1 и q2
phB := (q1-1)*(q2-1);

# Формирование открытого ключа, известного взломщику
# Далее выполняются действия взломщика

# Вычисление модуля n = q1 * q2 (открытая часть ключа)
rB := q1*q2;
# Генерация открытой экспоненты e, взаимно простой с phB
e := nextprime(Generate(integer(range=3..10^15))):
while (igcd(e, phB) <> 1) do
e := nextprime(Generate(integer(range=3..10^15))) end do:
e;

# Перехватывание зашифрованного сообщения
# Генерация случайного сообщения для демонстрации
m1 := Generate(integer(range=10..10^15)) mod rB;

# Криптоанализ: факторизация модуля rB
# Разложение rB на простые множители для получения секретных p и q
s:=ifactors(rB);
# Извлечение первого простого числа
p1 := s[2][1][1];
# Извлечение второго простого числа
p2 := s[2][2][1];

# Вычисление функции Эйлера для взломанных простых чисел
phb := phi(p1)*phi(p2);

# Вычисление секретного ключа d с использованием взломанных данных
d := e&^(phi(phb)-1) mod phb;

# Проверка корректности взлома
# Сравнение вычисленной и исходной функции Эйлера
phb-phB;
# Проверка того, что d*e ≡ 1 (mod φ(n))
(d*e) mod phb;